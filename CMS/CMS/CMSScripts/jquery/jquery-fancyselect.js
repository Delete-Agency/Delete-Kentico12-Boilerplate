// CUSTOMIZATION: we need to use the newest version of jQuery here, so $ is taken from dependency to jQuery which will be resolved to newest version. 
// By default, fancyselect takes jQuery from window.jQuery which is older version in CMS. We need it to work with new version in order to be compatible 
// with the rest of the system.
cmsdefine(['jQuery'], function ($) {

    // Generated by CoffeeScript 1.6.3
    (function() {
        $.fn.fancySelect = function(opts) {
            var isiOS, settings;
            if (opts == null) {
                opts = {};
            }
            settings = $.extend({
                forceiOS: false,
                includeBlank: false,
                optionTemplate: function(optionEl) {
                    return optionEl.text();
                },
                triggerTemplate: function(optionEl) {
                    return optionEl.text();
                }
            }, opts);
            isiOS = !!navigator.userAgent.match(/iP(hone|od|ad)/i);
            return this.each(function() {
                var copyOptionsToList, disabled, options, sel, trigger, updateTriggerText, wrapper, hasFocus;
                sel = $(this);
                if (sel.hasClass('fancified') || sel[0].tagName !== 'SELECT') {
                    return;
                }
                sel.addClass('fancified');
                sel.css({
                    width: 1,
                    height: 1,
                    display: 'block',
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    opacity: 0
                });
                sel.wrap('<div class="fancy-select">');
                wrapper = sel.parent();
                if (sel.data('class')) {
                    wrapper.addClass(sel.data('class'));
                }
                wrapper.append('<div class="dropdown">');
                if (!(isiOS && !settings.forceiOS)) {
                    wrapper.append('<ul class="dropdown-menu">');
                }
                trigger = wrapper.find('.dropdown');
                options = wrapper.find('.dropdown-menu');
                disabled = sel.prop('disabled');
                if (disabled) {
                    wrapper.addClass('disabled');
                }
                updateTriggerText = function() {
                    /* CMS */
                    var triggerHtml,
                        selectedElem = sel.find(':selected');

                    // Don't update trigger text if element's value is '-2' .
                    // It is (More sites) option in site selector which we don't want to propagate to label.
                    if (selectedElem.val() != '-2') {
                        triggerHtml = settings.triggerTemplate(selectedElem);

                        return trigger.text(triggerHtml).html();
                    }
                    /* CMS end */
                };
                sel.on('blur', function() {
                    if (trigger.hasClass('open') && hasFocus) {
                        return setTimeout(function() {
                            return trigger.trigger('close');
                        }, 120);
                    }
                });
                /* CMS special focus handling because of IE */
                sel.focusin(function() {
                    hasFocus = true;
                });
                sel.focusout(function() {
                    hasFocus = false;
                });
                /* CMS end */
                trigger.on('close', function() {
                    trigger.removeClass('open');
                    return options.removeClass('open');
                });
                trigger.on('click', function() {
                    var offParent, parent;
                    if (!disabled) {
                        trigger.toggleClass('open');
                        if (isiOS && !settings.forceiOS) {
                            if (trigger.hasClass('open')) {
                                return sel.focus();
                            }
                        } else {
                            if (trigger.hasClass('open')) {
                                parent = trigger.parent();
                                offParent = parent.offsetParent();
                                if ((parent.offset().top + parent.outerHeight() + options.outerHeight() + 20) > $(window).height() + $(window).scrollTop()) {
                                    options.addClass('overflowing');
                                } else {
                                    options.removeClass('overflowing');
                                }
                            }
                            options.toggleClass('open');
                            if (!isiOS) {
                                return sel.focus();
                            }
                        }
                    }
                });
                sel.on('enable', function() {
                    sel.prop('disabled', false);
                    wrapper.removeClass('disabled');
                    disabled = false;
                    return copyOptionsToList();
                });
                sel.on('disable', function() {
                    sel.prop('disabled', true);
                    wrapper.addClass('disabled');
                    return disabled = true;
                });
                sel.on('change', function(e) {
                    if (e.originalEvent && e.originalEvent.isTrusted) {
                        return e.stopPropagation();
                    } else {
                        return updateTriggerText();
                    }
                });
                sel.on('keydown', function(e) {
                    var hovered, newHovered, w;
                    w = e.which;
                    hovered = options.find('.hover');
                    hovered.removeClass('hover');
                    if (!options.hasClass('open')) {
                        if (w === 13 || w === 32 || w === 38 || w === 40) {
                            e.preventDefault();
                            return trigger.trigger('click');
                        }
                    } else {
                        if (w === 38) {
                            e.preventDefault();
                            if (hovered.length && hovered.index() > 0) {
                                hovered.prev().addClass('hover');
                            } else {
                                options.find('li:last-child').addClass('hover');
                            }
                        } else if (w === 40) {
                            e.preventDefault();
                            if (hovered.length && hovered.index() < options.find('li').length - 1) {
                                hovered.next().addClass('hover');
                            } else {
                                options.find('li:first-child').addClass('hover');
                            }
                        } else if (w === 27) {
                            e.preventDefault();
                            trigger.trigger('click');
                        } else if (w === 13 || w === 32) {
                            e.preventDefault();
                            hovered.trigger('click');
                        } else if (w === 9) {
                            if (trigger.hasClass('open')) {
                                trigger.trigger('close');
                            }
                        }
                        newHovered = options.find('.hover');
                        if (newHovered.length) {
                            options.scrollTop(0);
                            return options.scrollTop(newHovered.position().top - 12);
                        }
                    }
                });
                options.on('click', 'li', function(e) {
                    var clicked;
                    clicked = $(this);
                    sel.val(clicked.data('raw-value'));
                    if (!isiOS) {
                        sel.trigger('blur').trigger('focus');
                    }
                    options.find('.selected').removeClass('selected');
                    clicked.addClass('selected');
                    return sel.val(clicked.data('raw-value')).trigger('change').trigger('blur').trigger('focus');
                });
                options.on('mouseenter', 'li', function() {
                    var hovered, nowHovered;
                    nowHovered = $(this);
                    hovered = options.find('.hover');
                    hovered.removeClass('hover');
                    return nowHovered.addClass('hover');
                });
                options.on('mouseleave', 'li', function() {
                    return options.find('.hover').removeClass('hover');
                });
                copyOptionsToList = function() {
                    var selOpts;
                    updateTriggerText();
                    if (isiOS && !settings.forceiOS) {
                        return;
                    }
                    selOpts = sel.find('option');
                    return sel.find('option').each(function(i, opt) {
                        var optHtml;
                        opt = $(opt);
                        if (!opt.prop('disabled') && (opt.val() || settings.includeBlank)) {
                            optHtml = settings.optionTemplate(opt);
                            optHtml = $('<div/>').text(optHtml).html();

                            if (opt.prop('selected')) {
                                return options.append("<li data-raw-value=\"" + (opt.val()) + "\" class=\"dropdown-header selected\">" + optHtml + "</li>");
                            } else {
                                return options.append("<li data-raw-value=\"" + (opt.val()) + "\" class=\"dropdown-header\">" + optHtml + "</li>");
                            }
                        }
                    });
                };
                sel.on('update', function() {
                    wrapper.find('.drop').empty();
                    return copyOptionsToList();
                });
                return copyOptionsToList();
            });
        };

    }).call(this);
});